---
title: "NewCrafts 2018"
date: "2018-05-31"
path: "/articles/newcrafts-2018/"
tags:
  - "Conferences"
  - "NewCrafts"
---

Jeudi 17 et vendredi 18 mai 2018 avait lieu √† Paris la conf√©rence NewCrafts, et j'y ai particip√© pour la 2e ann√©e cons√©cutive.

C'est une conf√©rence en anglais, sur le th√®me du d√©veloppement logiciel. L'organisation est impeccable, les intervenant(e)s vari√©(e)s, pointu(e)s, et inspirant(e)s.

Il y a plusieurs *tracks* en parall√®le, plus des ateliers, et aussi les discussions dans les couloirs, et c'est donc parfois difficile de choisir vers o√π suivre ses pieds.

La premi√®re journ√©e, j'ai assist√© √† pas mal de pr√©sentations, alors que la deuxi√®me j'avais plut√¥t envie de pratiquer avec du code, et j'ai donc privil√©gi√© des ateliers. Et pendant ces deux jours, les diff√©rents moments de pause ont √©t√© l'occasion de nombreuses discussions enrichissantes avec les autres participants !

Voici quelques notes sur des choses qui m'ont int√©ress√©, surpris, amus√©, ou encore questionn√© pendant ces deux jours.

## Fighting the Invisible Enemy (Paul Rayner)

Ce qui va √† l'encontre du *flow* dans nos processus de d√©veloppement de produits, ce sont les queues invisibles qui se forment : par exemple, une fonctionnalit√© est d√©velopp√©e mais en attente d'√™tre test√©e ou d√©ploy√©e.

Les queues sont des indicateurs avanc√©s (*leading indicators*), contrairement au d√©bit (*throughput*) ou au temps de cycle (*cycle time*). Il est donc important de prendre conscience de ces queues, de les rendre visibles, et surtout d'agir rapidement et de mani√®re d√©cisive quand elles commencent √† grossir, avant que les cons√©quences ne se manifestent de mani√®re plus probl√©matique au niveau de l'ensemble du syst√®me.

Paul Rayner a utilis√© des mod√®les de traffic routier (http://traffic-simulation.de) pour illustrer de mani√®re tr√®s parlante les comportements non lin√©aires qui apparaissent √† la moindre perturbation d√®s lors que le syst√®me fonctionne √† un niveau de capacit√© √©lev√©.

Il nous a aussi montr√© un outil sur lequel il travaille, et qui s'appelle tout simplement [Flow](http://flow.virtualgenius.com). Celui-ci extrait les donn√©es temporelles depuis Pivotal Tracker / Jira / etc. pour visualiser le temps pass√© par chaque ticket dans chaque √©tape, et mieux identifier les temps d'attente.

Cette approche visuelle m'a fait penser √† un autre outil du *Lean*, le diagramme de flux cumul√© (*cumulative flow diagram*).

<iframe src="//www.slideshare.net/slideshow/embed_code/key/D3V9EXgiLiTpQD" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <p> <strong> <a href="//www.slideshare.net/virtualgenius/fighting-the-invisible-enemy-paul-rayner-newcrafts-2018" title="Fighting the Invisible Enemy - Paul Rayner (NewCrafts 2018)" target="_blank">Fighting the Invisible Enemy - Paul Rayner (NewCrafts 2018)</a> </strong> from <strong><a href="https://www.slideshare.net/virtualgenius" target="_blank">Paul Rayner</a></strong> </p>

## Feature Branching is Evil (Thierry de Pauw)

Thierry nous raconte son exp√©rience en tant que consultant avec deux projets assez diff√©rents.

La premi√®re √©quipe √©tait peu exp√©riment√©e, et n'utilisait auparavant aucun syst√®me de gestion de versions. Pour rester simple, il les a aid√© √† adopter Subversion : seulement deux gestes √† apprendre (*checkout*, et *commit*), et pas de branches. Il avait pens√© √ßa comme une premi√®re √©tape, mais en fait √ßa marchait pas mal.

La deuxi√®me √©quipe √©tait constitu√©e de d√©veloppeurs exp√©riment√©s, qui avait choisi d'utiliser git et le mode de fonctionnement "git flow". Lorsqu'il leur a sugg√©r√© d'arr√™ter les branches √† longue dur√©e de vie, il s'est heurt√© √† une forte incompr√©hension :

- mais les branches nous permettent de travailler chacun de notre c√¥t√© sans √™tre perturb√© par les changements des autres !
- mais les branches nous permettent de jeter un refactoring s'il ne va nulle part !
- mais les branches nous permettent de contr√¥ler la qualit√© de ce qu'on livre (via une revue de code pre-merge)
- mais les branches nous permettent de contr√¥ler quelles fonctionnalit√©s on livre (on ne merge que quand on veut livrer)

Dans sa pr√©sentation, Thierry a abord√© :

- les inconv√©nients des branches √† longue dur√©e de vie :
    - elles retardent le feedback,
    - elles retardent l'int√©gration,
    - elles cachent le travail du reste de l'√©quipe et r√©duisent la communication,
    - elles d√©couragent le refactoring,
    - elles cr√©ent du stock (au sens du Lean),
    - elles augmentent le risque,
    - elles cr√©ent du travail suppl√©mentaire (brancher, rebaser, merger‚Ä¶),
- les avantages  du *trunk-based development* :
    - commits plus fr√©quents sur master ‚Üí builds plus fr√©quents ‚Üí d√©ploiements plus fr√©quents ‚Üí time-to-market r√©duit ‚Üí exp√©rimentation plus facile
    - builds plus fr√©quents ‚Üí les probl√®mes sont d√©tect√©s plus t√¥t ‚Üí la qualit√© est am√©lior√©e
- comment faire du *trunk-based development* :
    - l'application est toujours pr√™te √† √™tre livr√©e sur la branche principale,
    - d√©couper les gros changements en petits morceaux incr√©mentaux,
    - garder cach√©es les nouvelles fonctionnalit√©s non termin√©es,
    - utiliser la technique "*branch by abstraction*" pour les gros refactorings,
    - utiliser les *feature toggles* (mais en dernier recours)
- comment remplacer la revue de code  ?
    - le *pair programming* est une solution possible (revue de code continue *pre-commit*)
    - on peut aussi faire une revue de code *post-commit*
        - *pre-merge* :  *pull requests* fr√©quentes sur des branches √† dur√©e de vie courte
        - *post-merge* : revue de code de tous les commits pouss√©s sur *master*
- au del√† des raisons invoqu√©es explicitement, quels sont les peurs qui font qu'une √©quipe peut r√©sister √† l'adoption de ce mod√®le ?
    - les d√©veloppeurs ne savent pas d√©velopper par petits incr√©ments ‚Üí c'est une comp√©tence encore trop rare, qui doit s'acqu√©rir
    - la base de code est trop coupl√©e, et manque de tests ‚Üí c'est difficile de changer quoi que ce soit sans craindre de casser quelque chose
    - les builds sont trop lents ‚Üí üê¢

<script async class="speakerdeck-embed" data-id="79065390625d45f484342b18d522d54a" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


## The Origins of Opera and the Future of Programming (Jessica Kerr)

Je regrette de ne pas avoir pu voir cette pr√©sentation. En attendant la vid√©o, un article de blog est disponible qui en reprend la trame : https://the-composition.com/the-origins-of-opera-and-the-future-of-programming-bcdaf8fbe960


## Endangered Species: Senior Craftsmen (Cyrille Dupuydauby)

Le goulot d'√©tranglement dans nos m√©tiers, c'est l'apprentissage. Il n'y a pas beaucoup de d√©veloppeurs qui ont 10 ans d'exp√©rience, et encore moins qui en ont 20. Doit-on compter sur eux pour enseigner le m√©tier aux nouveaux ? Seule une petite partie d'entre eux a envie de devenir prof, le reste pr√©f√®re sans doute programmer. C'est tous ensemble, en tant que communaut√©, que nous devons √™tre une organisation apprenante. Chacun, quel que soit le stade o√π il en est, peut aider les autres.

Slides : https://noti.st/dupdob/gX1kor/endangered-species-senior-crafters


## How to take smart notes (S√∂nke Ahrens)

Les conseils pour prendre des notes sont g√©n√©ralement de les s√©parer (un cahier ou carnet par sujet / mati√®re), de les relire d√®s que possible‚Ä¶ Ce sont de mauvais conseils.

Les conseils sur comment √©crire un article, un rapport, un m√©moire, sont tr√®s lin√©aires : trouvez un sujet, puis faites des recherches, puis lisez et prenez des notes, puis faites un plan, puis r√©digez‚Ä¶ L'√©criture y est une t√¢che parmi d'autres, et la vision est tr√®s top-down. Une meilleure approche est possible !

Pour Richard Feynman, la pens√©e est indissociable de l'√©criture. Les notes ne sont pas une forme de stockage du r√©sultat de notre pens√©e, elles sont notre pens√©e elle-m√™me. L'esprit a besoin de cet √©chafaudage ext√©rieur qu'est l'√©criture.

Pendant sa carri√®re acad√©mique, Niklas Luhmann a √©crit environ 600 publications, dont plus de 60 livres, sur des sujets comme la sociologie, le droit, la politique, les m√©dias, la philosophie, l'art, l'amour‚Ä¶ Son secret ? Sa bo√Æte √† notes (Zettelkasten).

90 000 notes accumul√©es. √áa semble beaucoup, mais √ßa fait seulement 6 par jour.

Son syst√®me est simple mais terriblement efficace :

- une id√©e par note ; une note sert √† d√©velopper une id√©e
- chaque note a un identifiant not√© en haut √† gauche : 1, 2, 3‚Ä¶ ( une note peut renvoyer √† une autre par son identifiant not√© √† l'encre rouge dans le texte)
- il n'y a pas de classement hi√©rarchique, l'organisation est √©mergente : une note li√©e √† une autre peut √™tre ins√©r√©e derri√®re elle dans la bo√Æte, et recevoir un identifiant avec une branche (par exemple : 1a1) ; cela permet de retrouver des notes pertinentes √† proximit√©, et de d√©rouler ainsi le fil plus tard

En ins√©rant la r√©daction de ces notes √† ses activit√©s quotidiennes de lecture, s√©minaires, etc. l'√©criture n'est plus quelque chose de s√©par√© que l'on fera juste avant la deadline, mais devient un travail progressif et incr√©mental. Les questions √† creuser et les cat√©gories √©mergent. Les id√©es s'enrichissent les unes les autres. Penser, relier et comprendre deviennent des actions concr√®tes.

Pour en savoir plus : http://takesmartnotes.com


## Big corps as little panopticons. Agile coaches as colonial imperialists. (Romeu Moura)

Le [panoptique](https://fr.wikipedia.org/wiki/Panoptique) est une architecture de prison imagin√©e √† la fin du XVIIIe si√®cle par [Jeremy Bentham](https://fr.wikipedia.org/wiki/Jeremy_Bentham), et analys√©e au XXe si√®cle par [Michel Foucault](https://fr.wikipedia.org/wiki/Michel_Foucault) dans son livre ¬´ [Surveiller et punir](https://fr.wikipedia.org/wiki/Surveiller_et_punir) ¬ª.

Ses caract√©ristiques cl√©s sont que :

- les prisonniers sont toujours vus par les gardes et le savent ;
- les prisonniers ne voient pas les gardes ;
- les prisonniers ne se parlent pas entre eux.

Dans un premier temps, un prisonnier se comporte bien car il est observ√©. Mais dans un deuxi√®me temps, il est conditionn√© √† devenir son propre garde.

On peut comparer les entreprises √† des panoptiques. Les managers veulent une compl√®te visibilit√© sur ce que font leurs employ√©s (reporting, etc), mais ne communiquent pas sur ce qu'ils font, et les √©quipes ne se parlent pas. Les √©quipes finissent par devenir leurs propres gardes, et s'interdisent de faire certaines choses : ¬´ ah mais non, ici on ne peut pas faire √ßa ¬ª.

En Am√©rique du Sud, les colons n'ont pas r√©ussi √† transformer les autochtones en esclaves. Ils avaient la mauvaise habitude de se laisser mourir. Ils devaient donc importer des esclaves venant d'Afrique. Jusqu'√† ce que les missionnaires j√©suites trouvent la combine : une fois convertis √† la foi chr√©tienne, ils craignaient de mourir !

Les grandes entreprises d√©ploient des arm√©es de coachs pour effectuer leur "transformation agile". Il s'agit moins de transformer toute la structure (et certainement pas le haut de la pyramide), que d'imposer un changement √† certains

Pour Romeu, tous ces coaches agiles sont des j√©suites. Qu'ils croient ou non aux valeurs de l'agilit√©, ils sont envoy√©s pour changer la culture de ¬´ ces gens l√† bas ¬ª. Ils sont instrumentalis√©s.

Alors que faire ? Comprendre le syst√®me. Lire ¬´ Thinking in systems ¬ª. Lire Foucault (c'est dur). Regarder la pr√©sentation de Jessica ou lire son article.

Chacun d'entre nous a plus de pouvoir qu'il ne croit. Nous sommes conditionn√©s √† penser le contraire. Nous vivons dans une peur artificielle d'agir diff√©remment. Nous surestimons le pouvoir de notre hi√©rarchie. On les croit malveillants, mais ils sont dans la m√™me situation, √† un niveau diff√©rent. Et √† tous les niveaux, les gens aimeraient que les choses changent. Restez indign√©s !


## What is programming anyway? (Felienne Hermans)

On emploie souvent des m√©taphores pour expliquer ce qu'est la programmation. Dire que programmer c'est comme les maths, √ßa peut avoir un effet n√©gatif. Felienne sugg√®re de dire plut√¥t que programmer c'est comme √©crire. Tout le monde peut √©crire, et l'√©criture a des usages vari√©s : fiction, po√©sie, calligraphie, p√©tition, dissertation, liste de courses‚Ä¶

Cette pr√©sentation m'a aussi fait r√©aliser qu'Excel est un langage de programmation fonctionnelle, et que c'√©tait sans doute le meilleur langage de programmation, car des millions de gens l'utilisent sans le savoir‚Ä¶ Imaginez vous programmer en Java sans faire expr√®s !


## Atelier: 50 shades of FizzBuzz

L'atelier visait √† prendre un probl√®me simple (FizzBuzz) et √† explorer diff√©rentes mani√®res de l'impl√©menter, en se donnant des contraintes.

Par exemple, on a commenc√© en mode *zombie pair programming* : le co-pilote pouvait faire des gestes mais ne pouvait pas parler, seulement grogner ou dire ¬´ brains ! ¬ª.

On a ensuite enrichi les sp√©cifications et vu comment le code √©voluait.

J'ai profit√© d'une partie de l'atelier pour explorer comment utiliser le *property-based testing* pour exprimer les tests.

J'ai mis mes diff√©rentes versions sur GitHub : https://github.com/ronnix/50-shades-of-fizzbuzz


## Atelier: Evolutionary Design

L'atelier visait √† exp√©rimenter l'*evolutionary design*.

La premi√®re activit√© a consist√© √† impl√©menter, en groupes de 4-5 personnes, une nouvelle m√©thode sur une base de code existante (cool, c'√©tait en Python !), en mode *outside-in* TDD. √á'a √©t√© une exp√©rience √† la fois int√©ressante et p√©nible pour moi, car je pense plut√¥t √™tre de l'√©cole classique du TDD, et faire les choses en mode *London school* allait un peu contre mon penchant naturel‚Ä¶

La deuxi√®me activit√© a consist√©, toujours en groupes, √† prendre une base de code d√©velopp√©e par un autre groupe lors d'un pr√©c√©dent atelier o√π ils avaient plus de temps, et √† l'am√©liorer avec des refactorings.


## Dojo tournant en continu

Pendant toute la dur√©e de la conf√©rence, un dojo de programmation a eu lieu en continu, o√π chacun pouvait venir participer au d√©veloppement d'un jeu de la vie, en mode *mob programming*.

Je n'y ai particip√© que quelques minutes, mais c'√©tait tr√®s dr√¥le de voir appara√Ætre en acc√©l√©r√© les probl√®mes que l'on voit en entreprise sur des projets plus longs sur lesquels il y a du *turn over*. Le code devient tr√®s vite du code legacy, l'intention initiale est vite perdue, les connaissances se transmettent mal, les nouveaux venus veulent aller dans une direction qui a d√©j√† √©t√© essay√©e sans succ√®s par les pr√©c√©dents, mais ils ne le savent pas‚Ä¶


## Pauses, couloirs et soir√©e du jeudi

Les meilleures sessions, ce sont toujours les rencontres et les discussions avec les autres participants. J'ai √©t√© heureux de recroiser des gens que je ne vois pas souvent, et d'en rencontrer de nouveaux que j'aurai plaisir √† revoir l'an prochain !
